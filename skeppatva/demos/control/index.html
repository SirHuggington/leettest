<!-- FULL CODE: Tight Third-Person Camera with Right-Click Aiming -->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Improved Aiming with Right-Click Pointer Lock</title>
<style>
  body { margin: 0; overflow: hidden; background: #000; color: #fff; font-family: sans-serif; }
  #health, #score, #bossHealth {
    position: absolute; padding: 5px 10px; background: rgba(0,0,0,0.5); font-size: 16px;
  }
  #health { top: 10px; left: 10px; }
  #score { top: 10px; right: 10px; }
  #bossHealth { bottom: 10px; left: 10px; }
  #overlay {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    display: flex; align-items: center; justify-content: center;
    background: rgba(0,0,0,0.7); color: #fff; font-size: 48px; cursor: pointer;
    text-align: center;
  }
  #overlay.hidden { display: none; }
  #crosshair {
    position: absolute; top: 50%; left: 50%;
    width: 20px; height: 20px; margin: -10px 0 0 -10px;
    pointer-events: none;
    background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20"><circle cx="10" cy="10" r="1.5" fill="white"/><line x1="10" y1="0" x2="10" y2="6" stroke="white" stroke-width="1"/><line x1="10" y1="14" x2="10" y2="20" stroke="white" stroke-width="1"/><line x1="0" y1="10" x2="6" y2="10" stroke="white" stroke-width="1"/><line x1="14" y1="10" x2="20" y2="10" stroke="white" stroke-width="1"/></svg>');
  }
</style>
</head>
<body>
  <div id="health">Health: 100</div>
  <div id="score">Score: 0</div>
  <div id="bossHealth">Boss: 1000</div>
  <div id="overlay" class="hidden">Game Over<br><small>Click to Restart</small></div>
  <div id="crosshair"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script>
    let scene, camera, renderer, clock;
    let player = { health: 100, score: 0, pos: new THREE.Vector3(0,0,0), vel: new THREE.Vector3(), onGround: true, stunned: false, stunTime: 0 };
    let boss, bossMaterial, bossHealth = 1000, bossHitTime = 0;
    let bullets = [];
    let bossProjectiles = [];
    let keys = {};
    const moveSpeed = 5;
    const gravity = 15;
    const jumpSpeed = 8;
    let yaw = 0, pitch = 0;
    let canLook = false, gameOver = false;
    let victory = false;

    let thirdPerson = false;
    let shiftPressedLastFrame = false;

    let bossState = 'idle';
    let bossCooldowns = { swipe: 0, fireball: 0, roar: 0 };
    const bossSwipeRange = 2.5;
    const bossRoarRange = 4.5;
    const bossMoveSpeed = 3;

    const healthDiv = document.getElementById('health');
    const scoreDiv = document.getElementById('score');
    const bossHealthDiv = document.getElementById('bossHealth');
    const overlay = document.getElementById('overlay');
    const crosshair = document.getElementById('crosshair');

    let playerMesh;

    init();
    requestAnimationFrame(animate);

    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
      camera.position.set(0, 1.6, 0);
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(innerWidth, innerHeight);
      document.body.appendChild(renderer.domElement);
      clock = new THREE.Clock();

      const dirLight = new THREE.DirectionalLight(0xffffff, 1);
      dirLight.position.set(5, 10, 7.5);
      scene.add(dirLight, new THREE.AmbientLight(0x404040));

      const ground = new THREE.Mesh(
        new THREE.PlaneGeometry(100,100),
        new THREE.MeshPhongMaterial({ color: 0x222222 })
      );
      ground.rotation.x = -Math.PI/2;
      scene.add(ground);

      bossMaterial = new THREE.MeshPhongMaterial({ color: 0x550000, emissive: 0x770000, emissiveIntensity: 1, transparent: true });
      boss = new THREE.Mesh(new THREE.SphereGeometry(1.5, 16, 16), bossMaterial);
      boss.position.set(0,1.5,-30);
      scene.add(boss);

      const playerGeom = new THREE.BoxGeometry(0.5, 0.9, 0.3);
      const playerMat = new THREE.MeshPhongMaterial({ color: 0x2288ff });
      playerMesh = new THREE.Mesh(playerGeom, playerMat);
      scene.add(playerMesh);

      window.addEventListener('resize', onResize);
      document.addEventListener('keydown', e => {
        keys[e.code] = true;
        if(e.code === 'ShiftLeft' || e.code === 'ShiftRight') {
          if(!shiftPressedLastFrame) {
            thirdPerson = !thirdPerson;
            shiftPressedLastFrame = true;
            crosshair.style.display = thirdPerson ? 'none' : 'block';
          }
        }
      });
      document.addEventListener('keyup', e => {
        keys[e.code] = false;
        if(e.code === 'ShiftLeft' || e.code === 'ShiftRight') {
          shiftPressedLastFrame = false;
        }
      });

      renderer.domElement.addEventListener('contextmenu', e => e.preventDefault());
      renderer.domElement.addEventListener('mousedown', e => {
        if(e.button === 2) {
          renderer.domElement.requestPointerLock();
        } else if(e.button === 0) {
          shoot();
        }
      });
      document.addEventListener('mouseup', e => {
        if(e.button === 2) {
          document.exitPointerLock();
        }
      });
      document.addEventListener('pointerlockchange', () => {
        canLook = (document.pointerLockElement === renderer.domElement);
      });
      document.addEventListener('mousemove', e => {
        if(canLook && !gameOver) {
          yaw   -= e.movementX * 0.0025;
          pitch -= e.movementY * 0.0025;
          pitch = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, pitch));
        }
      });

      overlay.addEventListener('click', () => location.reload());
    }

    function onResize() {
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    }

    function shoot() {
      if(gameOver || player.stunned) return;
      const bullet = new THREE.Mesh(new THREE.SphereGeometry(0.1,8,8), new THREE.MeshBasicMaterial({ color: 0xffff00 }));
      bullet.position.copy(camera.position);
      const dir = new THREE.Vector3();
      camera.getWorldDirection(dir);
      bullet.userData = { vel: dir.multiplyScalar(50) };
      bullets.push(bullet);
      scene.add(bullet);
    }

    function animate() {
      const dt = Math.min(clock.getDelta(), 0.1);
      if(!gameOver) {
        updatePlayer(dt);
        updateBoss(dt);
        updateBullets(dt);
        updateBossProjectiles(dt);
        updateUI();
      }
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    function updatePlayer(dt) {
      if(player.stunned) {
        player.stunTime -= dt;
        if(player.stunTime <= 0) player.stunned = false;
        return;
      }

      const inputDir = new THREE.Vector3();
      if(keys['KeyW']) inputDir.z -= 1;
      if(keys['KeyS']) inputDir.z += 1;
      if(keys['KeyA']) inputDir.x -= 1;
      if(keys['KeyD']) inputDir.x += 1;
      if(inputDir.lengthSq() > 0) inputDir.normalize();

      const eY = new THREE.Euler(0, yaw, 0);
      const moveDir = inputDir.applyEuler(eY);

      player.pos.x += moveDir.x * moveSpeed * dt;
      player.pos.z += moveDir.z * moveSpeed * dt;

      if(keys['Space'] && player.onGround) {
        player.vel.y = jumpSpeed;
        player.onGround = false;
      }

      player.vel.y -= gravity * dt;
      player.pos.y += player.vel.y * dt;
      if(player.pos.y <= 0) {
        player.pos.y = 0;
        player.vel.y = 0;
        player.onGround = true;
      }

      playerMesh.position.copy(player.pos);
      playerMesh.position.y += 0.45;
      if(inputDir.lengthSq() > 0) {
        const targetYaw = Math.atan2(moveDir.x, moveDir.z);
        playerMesh.rotation.y += shortestAngleDist(playerMesh.rotation.y, targetYaw) * 0.2;
      } else {
        playerMesh.rotation.y += shortestAngleDist(playerMesh.rotation.y, yaw) * 0.2;
      }

      if(thirdPerson) {
        const distance = 4;
        const spherical = new THREE.Spherical(distance, Math.PI / 2 + pitch, yaw);

        const offset = new THREE.Vector3().setFromSpherical(spherical);
        const camTarget = new THREE.Vector3().copy(player.pos).add(new THREE.Vector3(0, 1.5, 0));
        camera.position.copy(camTarget).add(offset);
        camera.lookAt(camTarget);
      } else {
        camera.position.copy(player.pos);
        camera.position.y += 0.8;
        camera.rotation.set(pitch, yaw, 0, 'YXZ');
      }
    }

    function shortestAngleDist(a, b) {
      let diff = b - a;
      while(diff > Math.PI) diff -= 2 * Math.PI;
      while(diff < -Math.PI) diff += 2 * Math.PI;
      return diff;
    }

    // === Rest of boss, bullets, projectiles, UI ===
    function updateBoss(dt) {
      if(bossHealth <= 0) {
        if(!victory) {
          victory = true;
          overlay.textContent = 'YOU KILLED CTHULHU AND AWOKE LOVECRAFT!\nClick to Restart';
          overlay.classList.remove('hidden');
        }
        return;
      }

      for(const key in bossCooldowns) {
        if(bossCooldowns[key] > 0) bossCooldowns[key] -= dt;
      }

      const toPlayer = new THREE.Vector3().subVectors(player.pos, boss.position);
      toPlayer.y = 0;
      if(toPlayer.lengthSq() > 0.0001) {
        boss.rotation.y = Math.atan2(toPlayer.x, toPlayer.z);
      }

      const dist = toPlayer.length();

      if(bossState === 'idle') {
        if(dist > bossSwipeRange + 1) bossState = 'moving';
        else bossState = 'attacking';
      } else if(bossState === 'moving') {
        if(dist > bossSwipeRange) {
          const moveStep = toPlayer.clone().normalize().multiplyScalar(bossMoveSpeed * dt);
          boss.position.add(moveStep);
        } else bossState = 'attacking';
      } else if(bossState === 'attacking') {
        if(dist <= bossSwipeRange && bossCooldowns.swipe <= 0) bossSwipeAttack();
        else if(dist <= bossRoarRange && bossCooldowns.roar <= 0) bossRoarAttack();
        else if(bossCooldowns.fireball <= 0) bossFireballAttack();
        else if(dist > bossSwipeRange) bossState = 'moving';
      } else if(bossState === 'roaring' || bossState === 'shooting') {
        // wait for animation
      }

      bossMaterial.emissiveIntensity = 
        (bossState === 'attacking' || bossState === 'roaring' || bossState === 'shooting') ?
        1 + Math.sin(Date.now() * 0.01) * 0.5 : 1;
    }

    function bossSwipeAttack() {
      bossState = 'attacking';
      bossCooldowns.swipe = 3;
      const originalScale = boss.scale.clone();
      new TWEEN.Tween(boss.scale).to({ x: 1.5, y: 1.2, z: 1.5 }, 300).yoyo(true).repeat(1).start();
      if(boss.position.distanceTo(player.pos) <= bossSwipeRange) damagePlayer(15);
    }

    function bossRoarAttack() {
      bossState = 'roaring';
      bossCooldowns.roar = 8;
      new TWEEN.Tween(boss.scale).to({ x: 2.2, y: 2.2, z: 2.2 }, 500).yoyo(true).repeat(1).start();
      bossMaterial.color.set(0xff2200);
      setTimeout(() => {
        bossMaterial.color.set(0x550000);
        bossState = 'idle';
      }, 1000);
      if(boss.position.distanceTo(player.pos) <= bossRoarRange) {
        player.stunned = true;
        player.stunTime = 2.5;
      }
    }

    function bossFireballAttack() {
      bossState = 'shooting';
      bossCooldowns.fireball = 4;
      bossMaterial.emissiveIntensity = 2;
      setTimeout(() => {
        bossMaterial.emissiveIntensity = 1;
        bossState = 'idle';
      }, 400);
      const fireball = new THREE.Mesh(new THREE.SphereGeometry(0.3, 8, 8), new THREE.MeshBasicMaterial({ color: 0xff4400 }));
      fireball.position.copy(boss.position);
      fireball.position.y += 1.5;
      const dir = new THREE.Vector3().subVectors(player.pos, fireball.position).normalize();
      fireball.userData = { vel: dir.multiplyScalar(15) };
      bossProjectiles.push(fireball);
      scene.add(fireball);
    }

    function updateBullets(dt) {
      for(let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.position.addScaledVector(b.userData.vel, dt);
        if(b.position.distanceTo(player.pos) > 100) {
          scene.remove(b);
          bullets.splice(i, 1);
          continue;
        }
        if(b.position.distanceTo(boss.position) < 1.5) {
          bossHealth -= 20;
          scene.remove(b);
          bullets.splice(i, 1);
        }
      }
    }

    function updateBossProjectiles(dt) {
      for(let i = bossProjectiles.length - 1; i >= 0; i--) {
        const p = bossProjectiles[i];
        p.position.addScaledVector(p.userData.vel, dt);
        if(p.position.distanceTo(player.pos) < 0.5) {
          damagePlayer(20);
          scene.remove(p);
          bossProjectiles.splice(i, 1);
          continue;
        }
        if(p.position.distanceTo(boss.position) > 50) {
          scene.remove(p);
          bossProjectiles.splice(i, 1);
        }
      }
    }

    function damagePlayer(amount) {
      if(player.stunned) return;
      player.health -= amount;
      if(player.health <= 0) {
        player.health = 0;
        gameOver = true;
        overlay.textContent = 'GAME OVER\nClick to Restart';
        overlay.classList.remove('hidden');
      }
    }

    function updateUI() {
      healthDiv.textContent = 'Health: ' + player.health.toFixed(0);
      scoreDiv.textContent = 'Score: ' + player.score.toFixed(0);
      bossHealthDiv.textContent = 'Boss Health: ' + bossHealth.toFixed(0);
    }

    // Tween.js loader and animateTweens function here
    if(typeof TWEEN === 'undefined') {
      const script = document.createElement('script');
      script.src = 'https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js';
      script.onload = () => animateTweens();
      document.head.appendChild(script);
    } else {
      animateTweens();
    }

    function animateTweens(time) {
      requestAnimationFrame(animateTweens);
      TWEEN.update(time);
    }
  </script>
</body>
</html>
