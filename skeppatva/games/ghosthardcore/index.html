<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Dice Chess (Multi‑Mode with Intro & Enforcement)</title>
  <style>
    body { background: #222; color: #fff; font-family: Arial, sans-serif; text-align: center; margin: 0; padding: 20px; }
    h1 { margin-bottom: 10px; }
    #intro, #settings, #game { max-width: 600px; margin: auto; text-align: left; }
    .hidden { display: none; }
    button { padding: 10px 20px; font-size: 16px; margin: 10px; background: #444; color: white; border: none; border-radius: 5px; cursor: pointer; }
    #dice { font-size: 40px; margin: 10px; }
    #allowed { font-size: 20px; }
    table { border-collapse: collapse; margin: 10px auto; }
    td { width: 50px; height: 50px; text-align: center; vertical-align: middle; font-size: 32px; cursor: pointer; user-select: none; transition: background-color 0.2s; }
    .white { background: #f0d9b5; }
    .black { background: #b58863; }
    .selected { outline: 3px solid yellow; }
    .red { color: #ff4d4d; }
    .blue { color: #4d94ff; }
    #scoreboard { display: flex; justify-content: space-around; margin:10px; }
    #scoreboard div { font-size: 18px; }
    .mode-desc, .opt-desc { font-size: 14px; margin-left: 20px; margin-bottom: 10px; }
  </style>
</head>
<body>

  <!-- === INTRO === -->
  <div id="intro" style="
    background-image: url('your-background.png');
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    color: #111;
    padding: 20px;
  ">
    <h1>🎲 Dice Chess</h1>
    <p>Dice Chess adds a roll‑to‑move mechanic on top of standard chess. Each turn you roll a die (1–6) to determine which piece type you can move:</p>
    <ul>
      <li>1: Pawn</li><li>2: Knight</li><li>3: Bishop</li>
      <li>4: Rook</li><li>5: Queen</li><li>6: King</li>
    </ul>
    <h2>Modes</h2>
    <ul>
      <li><strong>Basic</strong>: Classic (Ghost) chess rules—king‑capture wins. Scoring for fun.</li>
      <li><strong>Mode 1: Capture‑Value</strong>: Points per capture (P=1,N/B=3,R=5,Q=9). First to 30 wins.</li>
      <li><strong>Mode 2: Capture+Survival</strong>: +0.5 pts per move plus capture points. Highest after 40 turns or checkmate wins.</li>
      <li><strong>Mode 3: Threshold→Sudden‑Death</strong>: Capture points; at 25 pts sudden‑death—next checkmate wins.</li>
    </ul>
    <h2>Options</h2>
    <ul>
      <li><label><input type="checkbox" id="optSurvival"> Survival Bonus</label> — +0.5 pts per move.</li>
      <li><label><input type="checkbox" id="optReroll"> Reroll Credit</label> — +0.2 pts if you roll a piece you have none of instead of skipping turn.</li>
      <li><label><input type="checkbox" id="optEnforce"> Enforce Dice Move</label> — lock you into the rolled piece type.</li>
    </ul>
    <div style="text-align:center"><button onclick="showSettings()">Continue</button></div>
  </div>

  <!-- === SETTINGS === -->
  <div id="settings" class="hidden">
    <h2>Choose Mode & Options</h2>
    <label><input type="radio" name="mode" value="basic" checked> Basic</label>
      <div class="mode-desc">Classic (👻) chess—king capture wins. Scoring for fun.</div>
    <label><input type="radio" name="mode" value="rs1"> Mode 1: Capture‑Value</label>
      <div class="mode-desc">First to 30 pts via captures wins.</div>
    <label><input type="radio" name="mode" value="rs2"> Mode 2: Capture+Survival</label>
      <div class="mode-desc">+0.5 pts per move + captures. Highest after 40 turns wins.</div>
    <label><input type="radio" name="mode" value="rs3"> Mode 3: Threshold→Sudden‑Death</label>
      <div class="mode-desc">25 pts triggers sudden‑death: next checkmate wins.</div>
    <div style="text-align:center"><button onclick="startGame()">Start Game</button></div>
  </div>

  <!-- === GAME === -->
  <div id="game" class="hidden">
    <div id="scoreboard">
      <div>Red (P1): <span id="score1">0</span></div>
      <div>Blue (P2): <span id="score2">0</span></div>
    </div>
    <div style="text-align:center"><button onclick="rollDice()">Roll Dice</button></div>
    <div style="text-align:center">
      <div id="dice">🎲</div>
      <div id="allowed">Allowed piece: -</div>
    </div>
    <table id="chessboard"></table>
  </div>

  <script>
  // —————————————————————————————
  // ELEMENTS
  const introEl   = document.getElementById('intro');
  const settingsEl= document.getElementById('settings');
  const gameEl    = document.getElementById('game');
  const boardEl   = document.getElementById('chessboard');
  const diceEl    = document.getElementById('dice');
  const allowedEl = document.getElementById('allowed');
  const score1El  = document.getElementById('score1');
  const score2El  = document.getElementById('score2');

  // —————————————————————————————
  // STATE
  let board, turn, allowedType;
  let mode, optSurvival, optReroll, optEnforce, suddenDeath;
  let score1, score2, turnsCount;
  const threshold = 25, winTarget = 30;

  const initialPosition = [
    ['r','n','b','q','k','b','n','r'],
    ['p','p','p','p','p','p','p','p'],
    ['','','','','','','',''],
    ['','','','','','','',''],
    ['','','','','','','',''],
    ['','','','','','','',''],
    ['P','P','P','P','P','P','P','P'],
    ['R','N','B','Q','K','B','N','R'],
  ];

  const pieceNames = { p:'Pawn', n:'Knight', b:'Bishop', r:'Rook', q:'Queen', k:'King' };
  const pieceIcons = { p:'♟',r:'♜',n:'♞',b:'♝',q:'♛',k:'♚',P:'♙',R:'♖',N:'♘',B:'♗',Q:'♕',K:'♔' };
  const values     = { p:1,n:3,b:3,r:5,q:9,k:0 };

  // —————————————————————————————
  function showSettings() {
    introEl.classList.add('hidden');
    settingsEl.classList.remove('hidden');
  }

  function startGame() {
    // read settings
    mode       = document.querySelector('input[name=mode]:checked').value;
    optSurvival= document.getElementById('optSurvival').checked;
    optReroll  = document.getElementById('optReroll').checked;
    optEnforce = document.getElementById('optEnforce').checked;
    // Modes 2 & 3 force enforcement
    if (mode==='rs2' || mode==='rs3') optEnforce = true;
    // init state
    board = JSON.parse(JSON.stringify(initialPosition));
    turn = 'w'; allowedType = null; suddenDeath = false;
    score1 = score2 = turnsCount = 0;
    updateScores();
    settingsEl.classList.add('hidden');
    gameEl.classList.remove('hidden');
    drawBoard();
  }

  // —————————————————————————————
  function rollDice() {
    // roll and show
    const roll = Math.floor(Math.random()*6)+1;
    const types = ['p','n','b','r','q','k'];
    allowedType = types[roll-1];
    // enforcement with auto‑reroll
    if (optEnforce) {
      // try one reroll if no legal move
      if (!hasLegalMoveForType(allowedType)) {
        // first reroll
        const second = Math.floor(Math.random()*6)+1;
        allowedType = types[second-1];
        if (!hasLegalMoveForType(allowedType)) {
          alert('No valid moves for rolled piece. Turn skipped.');
          skipTurn();
          return;
        }
      }
    }
    diceEl.textContent    = `🎲 ${roll}`;
    allowedEl.textContent = `Allowed piece: ${pieceNames[allowedType]}`;
    selected = null;
    drawBoard();
  }

  function skipTurn() {
    // award reroll credit if on
    if (optReroll) {
      if (turn==='w') score1 += 0.2; else score2 += 0.2;
      updateScores();
    }
    // switch turn and redraw
    turn = turn==='w' ? 'b' : 'w';
    diceEl.textContent = '🎲'; allowedEl.textContent = 'Allowed piece: -';
    drawBoard();
  }

  // —————————————————————————————
  let selected = null;
  function drawBoard() {
    boardEl.innerHTML = '';
    for (let y=0; y<8; y++) {
      const tr = document.createElement('tr');
      for (let x=0; x<8; x++) {
        const cell = document.createElement('td');
        const p = board[y][x];
        cell.className = (x+y)%2===0 ? 'white' : 'black';
        cell.textContent = pieceIcons[p]||'';
        if (p) cell.classList.add(p===p.toUpperCase()?'red':'blue');
        if (selected && selected.x===x && selected.y===y) cell.classList.add('selected');
        cell.onclick = () => handleCellClick(x,y);
        tr.appendChild(cell);
      }
      boardEl.appendChild(tr);
    }
  }

  function handleCellClick(x,y) {
    const p = board[y][x];
    if (selected) {
      if (tryMove(selected.x,selected.y,x,y)) {
        selected = null; drawBoard(); checkEnd();
      } else {
        selected = null; drawBoard();
      }
    } else if (p && isPlayersPiece(p) && (!optEnforce || p.toLowerCase()===allowedType)) {
      selected = {x,y}; drawBoard();
    }
  }

  // —————————————————————————————
  function isPlayersPiece(p) {
    return turn==='w' ? p===p.toUpperCase() : p===p.toLowerCase();
  }

  // path checker for rooks/bishops/queens
  function isPathClear(sx, sy, dx, dy) {
    let xStep = dx===sx?0:(dx>sx?1:-1);
    let yStep = dy===sy?0:(dy>sy?1:-1);
    let x=sx+xStep, y=sy+yStep;
    while (x!==dx || y!==dy) {
      if (board[y][x] !== '') return false;
      x+=xStep; y+=yStep;
    }
    return true;
  }

  // validate a move without committing
  function canMove(sx,sy,dx,dy) {
    const p    = board[sy][sx], dest = board[dy][dx];
    if (!p) return false;
    if (dest && (turn==='w'?dest===dest.toUpperCase():dest===dest.toLowerCase())) return false;
    const dxA = Math.abs(dx-sx), dyA=Math.abs(dy-sy);
    const dir = turn==='w'?-1:1, t=p.toLowerCase();
    // pawn
    if (t==='p') {
      if (dx===sx && dy-sy===dir && !dest) return true;
      if (dxA===1 && dy-sy===dir && dest) return true;
      return false;
    }
    // rook
    if (t==='r') {
      if (sx===dx||sy===dy) return isPathClear(sx,sy,dx,dy);
      return false;
    }
    // knight
    if (t==='n') return (dxA===1&&dyA===2)||(dxA===2&&dyA===1);
    // bishop
    if (t==='b') return dxA===dyA;         // allow phasing
    // queen
    if (t==='q') return dxA===dyA||sx===dx||sy===dy; // allow phasing
    // king
    if (t==='k') return dxA<=1&&dyA<=1;
    return false;
  }

  // does current player have any legal move of that type?
  function hasLegalMoveForType(type) {
    for (let y=0;y<8;y++) for (let x=0;x<8;x++) {
      const p = board[y][x];
      if (p && ((turn==='w'?p===p.toUpperCase():p===p.toLowerCase())) && p.toLowerCase()===type) {
        for (let dy=0;dy<8;dy++) for (let dx=0;dx<8;dx++) {
          if (canMove(x,y,dx,dy)) return true;
        }
      }
    }
    return false;
  }

  function tryMove(sx,sy,dx,dy) {
    if (!canMove(sx,sy,dx,dy)) return false;
    // now commit
    const p    = board[sy][sx], dest=board[dy][dx];
    if (dest) {
      const pts = values[dest.toLowerCase()];
      if (turn==='w') score1+=pts; else score2+=pts;
    }
    if (optSurvival) {
      if (turn==='w') score1+=0.5; else score2+=0.5;
    }
    board[dy][dx]=p; board[sy][sx]='';
    turnsCount++; updateScores();
    // flip turn
    turn = turn==='w'?'b':'w';
    allowedType=null; diceEl.textContent='🎲'; allowedEl.textContent='Allowed piece: -';
    drawBoard();
    return true;
  }

  function hasPiece(color,type){
    return board.flat().some(p=>p && ((color==='w'?p===p.toUpperCase():p===p.toLowerCase()) && p.toLowerCase()===type));
  }
  function hasKing(color){
    return board.flat().some(p=>color==='w'?p==='K':p==='k');
  }
  function updateScores(){
    score1El.textContent=score1;
    score2El.textContent=score2;
  }
  function awardCheckmateBonus(winner){
    if (winner==='w'){score1+=10;score2+=2;}else{score2+=10;score1+=2;}
    updateScores();
  }
  function announceWinner(winner,draw=false){
    const name=winner==='w'?'Red (P1)':'Blue (P2)';
    if (draw) alert(`Draw! Final score — Red: ${score1}, Blue: ${score2}`);
    else alert(`${name} wins! Final score — Red: ${score1}, Blue: ${score2}`);
    location.reload();
  }
  function checkEnd(){
    if (!hasKing('w')||!hasKing('b')){
      const win=hasKing('w')?'w':'b';
      awardCheckmateBonus(win);
      announceWinner(win);
      return;
    }
    if (mode==='rs1'&&(score1>=winTarget||score2>=winTarget)){
      announceWinner(score1>=winTarget?'w':'b');return;
    }
    if (mode==='rs2'&&Math.floor(turnsCount/2)>=40){
      if (score1!==score2) announceWinner(score1>score2?'w':'b');
      else announceWinner(null,true);
      return;
    }
    if (mode==='rs3'&&!suddenDeath&&(score1>=threshold||score2>=threshold)){
      suddenDeath=true;
      alert('Threshold reached! Sudden‑death now: Next checkmate wins.');
    }
  }
  // —————————————————————————————
  </script>
</body>
</html>
